public class JiraIssues { <START_BUG> private static List < MutableIssue > jiraIssues ; <END_BUG> public static List < MutableIssue > getTestJiraIssues ( ) { if ( jiraIssues == null || jiraIssues . isEmpty ( ) ) {
List < String > status = new ArrayList < String > ( ) ; status . add ( KnowledgeStatus . UNRESOLVED . toString ( ) ) ; filterSettings . setSelectedStatus ( status ) ; <START_BUG> assertEquals ( 8 , filterSettings . getSelectedStatus ( ) . size ( ) ) ; <END_BUG> } }
* @ param labels labels of the sentences * @ return * / <START_BUG> Map < String , List > preprocess ( List < String > stringsToBePreprocessed , List labels ) ; <END_BUG> BinaryClassifierImpl getBinaryClassifier ( ) ;
private ViewRest viewRest ; private FilterSettings filterSettings ; <START_BUG> protected HttpServletRequest request ; <END_BUG> @ Before public void setUp ( ) {
import java . util . Date ; @ Entity <START_BUG> public class WachtwoordResetToken { <END_BUG> private static final int EXPIRATION = 60 * 24 ;
* / private void cleanupOldData ( SnapshotConfig config , TransactionPruner transactionPruner , int targetIndex ) throws SnapshotException { <START_BUG> int startingIndex = config . getMilestoneStartIndex ( ) + 1 ; <END_BUG> try { if ( targetIndex >= startingIndex ) {
* @ return true if this run also should be terminated * * / public boolean notifyPausedRun ( final PipelineRun run ) { <START_BUG> final Optional < RunStatus > lastRunStatus = run . getRunStatuses ( ) . stream ( ) <END_BUG> . max ( Comparator . comparing ( RunStatus :: getTimestamp ) ) ; final NotificationSettings settings = notificationSettingsManager . load ( NotificationType . LONG_PAUSED_RUN . getId ( ) ) ; final NotificationMessage notificationMessage = fillNotificationMessage ( run , settings ) ;
assertEquals ( loaded . getLastIdleNotificationTime ( ) , lastIdleNotificationDate ) ; } ) ; <START_BUG> List < PipelineRun > running = pipelineRunDao . loadRunningPipelineRuns ( ) ; <END_BUG> assertFalse ( running . isEmpty ( ) ) ; running . forEach ( loaded -> { assertEquals ( loaded . getLastNotificationTime ( ) , lastNotificationDate ) ;
* / private void cleanupOldData ( SnapshotConfig config , TransactionPruner transactionPruner , int targetIndex ) throws SnapshotException { <START_BUG> int startingIndex = config . getMilestoneStartIndex ( ) + 1 ; <END_BUG> try { if ( targetIndex >= startingIndex ) {
import sparksoniq . exceptions . InvalidArgumentTypeException ; import sparksoniq . exceptions . IteratorFlowException ; import sparksoniq . exceptions . OurBadException ; <START_BUG> import sparksoniq . exceptions . SparksoniqRuntimeException ; <END_BUG> import sparksoniq . jsoniq . runtime . metadata . IteratorMetadata ; import sparksoniq . semantics . DynamicContext ; import sparksoniq . semantics . types . ItemTypes ;
import sparksoniq . exceptions . IteratorFlowException ; import sparksoniq . exceptions . JobWithinAJobException ; import sparksoniq . exceptions . OurBadException ; <START_BUG> import sparksoniq . exceptions . SparksoniqRuntimeException ; <END_BUG> import sparksoniq . jsoniq . runtime . iterator . RuntimeIterator ; import sparksoniq . jsoniq . runtime . metadata . IteratorMetadata ; import sparksoniq . jsoniq . runtime . tupleiterator . RuntimeTupleIterator ;
) { super ( null , iteratorMetadata ) ; this . _operator = operator ; <START_BUG> children . forEach ( c -> this . _children . add ( c ) ) ; <END_BUG> this . _evaluationExpression = evaluationExpression ; _children . add ( _evaluationExpression ) ; }
+ arity + " parameters." , ErrorCodes . InvalidFunctionCallErrorCode , <START_BUG> iteratorMetadata . getExpressionMetadata ( ) <END_BUG> ) ; } }
import org . rumbledb . api . Item ; import sparksoniq . exceptions . IteratorFlowException ; import sparksoniq . exceptions . OurBadException ; <START_BUG> import sparksoniq . exceptions . SparksoniqRuntimeException ; <END_BUG> import sparksoniq . jsoniq . item . ItemFactory ; import sparksoniq . jsoniq . runtime . iterator . RuntimeIterator ; import sparksoniq . jsoniq . runtime . iterator . primary . VariableReferenceIterator ;
import scala . Tuple2 ; import sparksoniq . exceptions . IteratorFlowException ; import sparksoniq . exceptions . OurBadException ; <START_BUG> import sparksoniq . exceptions . SparksoniqRuntimeException ; <END_BUG> import sparksoniq . jsoniq . item . IntegerItem ; import sparksoniq . jsoniq . runtime . iterator . HybridRuntimeIterator ; import sparksoniq . jsoniq . runtime . iterator . RuntimeIterator ;
int sum = 0 ; long prod = 1 ; for ( int i = 0 ; i < 4 ; i ++ ) { <START_BUG> sum += realitemCost [ i ] . getUB ( ) ; <END_BUG> prod *= itemCost [ i ] . getValue ( ) ; System . out . println ( "item " + i + " : " + itemCost [ i ] . getValue ( ) ) ; }
@ Query ( value = "SELECT item_id FROM test_item WHERE path <@ cast(:path AS LTREE)" , nativeQuery = true ) List < Long > selectAllDescendantsIds ( @ Param ( "path" ) String path ) ; <START_BUG> void deleteAllByItemIds ( Iterable < Long > ids ) ; <END_BUG> }
import java . util . Optional ; <START_BUG> import com . eclipsesource . modelserver . client . ModelServerClient ; <END_BUG> import com . google . inject . Singleton ; @ Singleton
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * / package com . eclipsesource . glsp . example . modelserver . workflow . model ; <START_BUG> import static com . eclipsesource . glsp . api . utils . ServerStatusUtil . getDetails ; <END_BUG> import static com . eclipsesource . glsp . example . modelserver . workflow . model . WorkflowModelServerModelFactory . OPTION_WORKFLOW_INDEX ; import static com . eclipsesource . glsp . example . modelserver . workflow . model . WorkflowModelServerModelFactory . WORKFLOW_INDEX_DEFAULT ;
import com . eclipsesource . glsp . example . modelserver . workflow . wfnotation . Dimension ; import com . eclipsesource . glsp . example . modelserver . workflow . wfnotation . Point ; import com . eclipsesource . glsp . example . modelserver . workflow . wfnotation . WfnotationFactory ; <START_BUG> import com . eclipsesource . glsp . graph . GPoint ; <END_BUG> public class ShapeUtil {
protected static final String TIME_STRING_Z_TITLE = "Has the datasource time string a 'Z'" ; protected static final String TIME_STRING_Z_DESCRIPTION = <START_BUG> "Define if the datasoucre time string uses a 'Z' instead of '+00:00'." ; <END_BUG> protected static final boolean TIME_STRING_Z_DEFAULT_VALUE = false ;
return ( e instanceof ApiException ) ? ( ( ApiException ) e ) . getCode ( ) : 0 ; } <START_BUG> public < T > Function < ? super Throwable , Observable < T > > onError ( <END_BUG> IllegalArgumentException originalException ) { return ( Throwable e ) -> Observable . error ( exceptionHandling ( e , originalException ) ) ; }
for ( int i = 0 ; i < 32 ; i ++ ) { Ed25519GroupElement bij = bi ; <START_BUG> for ( int j = 0 ; j < 8 ; j ++ ) { <END_BUG> final Ed25519FieldElement inverse = bij . z . invert ( ) ; final Ed25519FieldElement xElement = bij . x . multiply ( inverse ) ; final Ed25519FieldElement yElement = bij . y . multiply ( inverse ) ;
. fromHexString ( "B72F2950498111BADF276D6D9D5E345F04E0D5C9B8342DA983C3395B4CF18F08" ) , networkType . resolveSignSchema ( ) ) ; <START_BUG> String typescriptEncryptedKey = "924D20FFB456740CF63988E8C39B2D56A165823E9F8DCFC4D7BD2389D582C8868B5C56A295CB0CFCF5A902C94A60FB79859EB651D1477D8A1470BB55712D0D4DC9F1C662AC224C6346BEF3690054271B" ; <END_BUG> EncryptedMessage encryptedMessage = new EncryptedMessage ( typescriptEncryptedKey ) ; String plainMessage = encryptedMessage
@ Override public void onFailure ( Call < List < Store > > call , Throwable throwable ) { <START_BUG> <END_BUG> } } ) ;
@ Override public void onFailure ( Call < Void > call , Throwable throwable ) { <START_BUG> <END_BUG> } } ) ; }
Node itemCell = viewData . getKey ( ) ; CatalogItemViewController controller = ( CatalogItemViewController ) viewData . getValue ( ) ; <START_BUG> int index = ( page - 1 ) + i * NUM_COLS + j ; <END_BUG> if ( index >= items . size ( ) ) break ; CatalogItem item = items . get ( index ) ;
@ Override public void onFailure ( Call < List < Store > > call , Throwable throwable ) { <START_BUG> <END_BUG> } } ) ; } else {
AbstractTransactionMapper < HashLockTransactionDTO , HashLockTransaction > { public HashLockTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . LOCK , HashLockTransactionDTO . class ) ; <END_BUG> } private Mosaic getMosaic ( HashLockTransactionDTO mosaic ) {
AbstractTransactionMapper < NamespaceMetadataTransactionDTO , NamespaceMetadataTransaction > { public NamespaceMetadataTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . NAMESPACE_METADATA_TRANSACTION , <END_BUG> NamespaceMetadataTransactionDTO . class ) ; }
expectedReceiptSource ) ; } <START_BUG> if ( transaction . getType ( ) == TransactionType . LOCK ) { <END_BUG> return resolveTransactionFactory ( ( HashLockTransaction ) transaction , expectedReceiptSource ) ; }
UnresolvedMosaicId targetMosaicId , BigInteger scopedMetadataKey , String value ) { <START_BUG> super ( TransactionType . MOSAIC_METADATA_TRANSACTION , networkType , targetAccount , <END_BUG> scopedMetadataKey , value ) ; Validate . notNull ( targetMosaicId , "TargetMosaicId must not be null" ) ; this . targetMosaicId = targetMosaicId ;
AbstractTransactionMapper < NamespaceRegistrationTransactionDTO , NamespaceRegistrationTransaction > { public NamespaceRegistrationTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . REGISTER_NAMESPACE , <END_BUG> NamespaceRegistrationTransactionDTO . class ) ; }
@ Override public TransactionType getTransactionType ( ) { <START_BUG> return TransactionType . LOCK ; <END_BUG> } @ Override
Validate . notNull ( signedAggregateTransaction , "signedAggregateTransaction is required" ) ; Validate . isTrue ( signedAggregateTransaction . getType ( ) == TransactionType . AGGREGATE_BONDED , "signedAggregateTransaction type must be AGGREGATE_BONDED" ) ; <START_BUG> Validate . isTrue ( signedHashLockTransaction . getType ( ) == TransactionType . LOCK , <END_BUG> "signedHashLockTransaction type must be LOCK" ) ; return announce ( listener , signedHashLockTransaction ) . flatMap ( t -> announceAggregateBonded ( listener , signedAggregateTransaction ) ) ;
final NamespaceRegistrationType namespaceRegistrationType , final Optional < BigInteger > duration , final Optional < NamespaceId > parentId ) { <START_BUG> super ( TransactionType . REGISTER_NAMESPACE , networkType ) ; <END_BUG> Validate . notNull ( namespaceName , "NamespaceName must not be null" ) ; Validate . notNull ( namespaceRegistrationType , "NamespaceType must not be null" ) ; Validate . notNull ( namespaceId , "NamespaceId must not be null" ) ;
AbstractTransactionMapper < NamespaceMetadataTransactionDTO , NamespaceMetadataTransaction > { public NamespaceMetadataTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . NAMESPACE_METADATA_TRANSACTION , <END_BUG> NamespaceMetadataTransactionDTO . class ) ; }
@ Override public TransactionType getTransactionType ( ) { <START_BUG> return TransactionType . ACCOUNT_METADATA_TRANSACTION ; <END_BUG> } @ Override
NamespaceId targetNamespaceId , BigInteger scopedMetadataKey , String value ) { <START_BUG> super ( TransactionType . NAMESPACE_METADATA_TRANSACTION , networkType , targetAccount , <END_BUG> scopedMetadataKey , value ) ; Validate . notNull ( targetNamespaceId , "TargetNamespaceId must not be null" ) ; this . targetNamespaceId = targetNamespaceId ;
Assertions . assertEquals ( AccountRestrictionFlags . ALLOW_INCOMING_MOSAIC , transaction . getRestrictionFlags ( ) ) ; Assertions . assertEquals ( 1 , transaction . getRestrictionAdditions ( ) . size ( ) ) ; <START_BUG> Assertions . assertEquals ( TransactionType . MOSAIC_METADATA_TRANSACTION , <END_BUG> transaction . getRestrictionAdditions ( ) . get ( 0 ) ) ; }
AbstractTransactionMapper < MultisigAccountModificationTransactionDTO , MultisigAccountModificationTransaction > { public MultisigAccountModificationTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . MODIFY_MULTISIG_ACCOUNT , <END_BUG> MultisigAccountModificationTransactionDTO . class ) ; }
@ Override public TransactionType getTransactionType ( ) { <START_BUG> return TransactionType . MOSAIC_METADATA_TRANSACTION ; <END_BUG> } @ Override
AbstractTransactionMapper < MosaicMetadataTransactionDTO , MosaicMetadataTransaction > { public MosaicMetadataTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . MOSAIC_METADATA_TRANSACTION , <END_BUG> MosaicMetadataTransactionDTO . class ) ; }
@ Override public TransactionType getTransactionType ( ) { <START_BUG> return TransactionType . NAMESPACE_METADATA_TRANSACTION ; <END_BUG> } @ Override
Assertions . assertEquals ( AccountRestrictionFlags . ALLOW_INCOMING_MOSAIC , transaction . getRestrictionFlags ( ) ) ; Assertions . assertEquals ( 1 , transaction . getRestrictionAdditions ( ) . size ( ) ) ; <START_BUG> Assertions . assertEquals ( TransactionType . MOSAIC_METADATA_TRANSACTION , <END_BUG> transaction . getRestrictionAdditions ( ) . get ( 0 ) ) ; }
AbstractTransactionMapper < MultisigAccountModificationTransactionDTO , MultisigAccountModificationTransaction > { public MultisigAccountModificationTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . MODIFY_MULTISIG_ACCOUNT , <END_BUG> MultisigAccountModificationTransactionDTO . class ) ; }
byte minRemovalDelta , List < PublicAccount > publicKeyAdditions , List < PublicAccount > publicKeyDeletions ) { <START_BUG> super ( TransactionType . MODIFY_MULTISIG_ACCOUNT , networkType ) ; <END_BUG> Validate . notNull ( publicKeyAdditions , "PublicKeyAdditions must not be null" ) ; Validate . notNull ( publicKeyDeletions , "PublicKeyDeletions must not be null" ) ; this . minApprovalDelta = minApprovalDelta ;
@ Override public TransactionType getTransactionType ( ) { <START_BUG> return TransactionType . REGISTER_NAMESPACE ; <END_BUG> } @ Override
@ Override public TransactionType getTransactionType ( ) { <START_BUG> return TransactionType . MODIFY_MULTISIG_ACCOUNT ; <END_BUG> } @ Override
AbstractTransactionMapper < HashLockTransactionDTO , HashLockTransaction > { public HashLockTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . LOCK , HashLockTransactionDTO . class ) ; <END_BUG> } private Mosaic getMosaic ( HashLockTransactionDTO mosaic ) {
AbstractTransactionMapper < NamespaceRegistrationTransactionDTO , NamespaceRegistrationTransaction > { public NamespaceRegistrationTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . REGISTER_NAMESPACE , <END_BUG> NamespaceRegistrationTransactionDTO . class ) ; }
AbstractTransactionMapper < MosaicMetadataTransactionDTO , MosaicMetadataTransaction > { public MosaicMetadataTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . MOSAIC_METADATA_TRANSACTION , <END_BUG> MosaicMetadataTransactionDTO . class ) ; }
PublicAccount targetAccount , BigInteger scopedMetadataKey , String value ) { <START_BUG> super ( TransactionType . ACCOUNT_METADATA_TRANSACTION , networkType , targetAccount , <END_BUG> scopedMetadataKey , value ) ; }
Mosaic mosaic , BigInteger duration , String hash ) { <START_BUG> super ( TransactionType . LOCK , networkType ) ; <END_BUG> Validate . notNull ( mosaic , "Mosaic must not be null" ) ; Validate . notNull ( duration , "Duration must not be null" ) ; Validate . notNull ( hash , "Hash must not be null" ) ;
expectedReceiptSource ) ; } <START_BUG> if ( transaction . getType ( ) == TransactionType . MOSAIC_METADATA_TRANSACTION ) { <END_BUG> return resolveTransactionFactory ( ( MosaicMetadataTransaction ) transaction , expectedReceiptSource ) ; }
AbstractTransactionMapper < AccountMetadataTransactionDTO , AccountMetadataTransaction > { public AccountMetadataTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . ACCOUNT_METADATA_TRANSACTION , <END_BUG> AccountMetadataTransactionDTO . class ) ; }
return ( e instanceof ApiException ) ? ( ( ApiException ) e ) . getCode ( ) : 0 ; } <START_BUG> public < T > Function < ? super Throwable , Observable < T > > onError ( <END_BUG> IllegalArgumentException originalException ) { return ( Throwable e ) -> Observable . error ( exceptionHandling ( e , originalException ) ) ; }
. fromHexString ( "B72F2950498111BADF276D6D9D5E345F04E0D5C9B8342DA983C3395B4CF18F08" ) , networkType . resolveSignSchema ( ) ) ; <START_BUG> String typescriptEncryptedKey = "924D20FFB456740CF63988E8C39B2D56A165823E9F8DCFC4D7BD2389D582C8868B5C56A295CB0CFCF5A902C94A60FB79859EB651D1477D8A1470BB55712D0D4DC9F1C662AC224C6346BEF3690054271B" ; <END_BUG> EncryptedMessage encryptedMessage = new EncryptedMessage ( typescriptEncryptedKey ) ; String plainMessage = encryptedMessage
AbstractTransactionMapper < HashLockTransactionDTO , HashLockTransaction > { public HashLockTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . LOCK , HashLockTransactionDTO . class ) ; <END_BUG> } private Mosaic getMosaic ( HashLockTransactionDTO mosaic ) {
AbstractTransactionMapper < NamespaceMetadataTransactionDTO , NamespaceMetadataTransaction > { public NamespaceMetadataTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . NAMESPACE_METADATA_TRANSACTION , <END_BUG> NamespaceMetadataTransactionDTO . class ) ; }
expectedReceiptSource ) ; } <START_BUG> if ( transaction . getType ( ) == TransactionType . LOCK ) { <END_BUG> return resolveTransactionFactory ( ( HashLockTransaction ) transaction , expectedReceiptSource ) ; }
UnresolvedMosaicId targetMosaicId , BigInteger scopedMetadataKey , String value ) { <START_BUG> super ( TransactionType . MOSAIC_METADATA_TRANSACTION , networkType , targetAccount , <END_BUG> scopedMetadataKey , value ) ; Validate . notNull ( targetMosaicId , "TargetMosaicId must not be null" ) ; this . targetMosaicId = targetMosaicId ;
AbstractTransactionMapper < NamespaceRegistrationTransactionDTO , NamespaceRegistrationTransaction > { public NamespaceRegistrationTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . REGISTER_NAMESPACE , <END_BUG> NamespaceRegistrationTransactionDTO . class ) ; }
@ Override public TransactionType getTransactionType ( ) { <START_BUG> return TransactionType . LOCK ; <END_BUG> } @ Override
Validate . notNull ( signedAggregateTransaction , "signedAggregateTransaction is required" ) ; Validate . isTrue ( signedAggregateTransaction . getType ( ) == TransactionType . AGGREGATE_BONDED , "signedAggregateTransaction type must be AGGREGATE_BONDED" ) ; <START_BUG> Validate . isTrue ( signedHashLockTransaction . getType ( ) == TransactionType . LOCK , <END_BUG> "signedHashLockTransaction type must be LOCK" ) ; return announce ( listener , signedHashLockTransaction ) . flatMap ( t -> announceAggregateBonded ( listener , signedAggregateTransaction ) ) ;
final NamespaceRegistrationType namespaceRegistrationType , final Optional < BigInteger > duration , final Optional < NamespaceId > parentId ) { <START_BUG> super ( TransactionType . REGISTER_NAMESPACE , networkType ) ; <END_BUG> Validate . notNull ( namespaceName , "NamespaceName must not be null" ) ; Validate . notNull ( namespaceRegistrationType , "NamespaceType must not be null" ) ; Validate . notNull ( namespaceId , "NamespaceId must not be null" ) ;
AbstractTransactionMapper < NamespaceMetadataTransactionDTO , NamespaceMetadataTransaction > { public NamespaceMetadataTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . NAMESPACE_METADATA_TRANSACTION , <END_BUG> NamespaceMetadataTransactionDTO . class ) ; }
@ Override public TransactionType getTransactionType ( ) { <START_BUG> return TransactionType . ACCOUNT_METADATA_TRANSACTION ; <END_BUG> } @ Override
AbstractTransactionMapper < AccountMetadataTransactionDTO , AccountMetadataTransaction > { public AccountMetadataTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . ACCOUNT_METADATA_TRANSACTION , <END_BUG> AccountMetadataTransactionDTO . class ) ; }
NamespaceId targetNamespaceId , BigInteger scopedMetadataKey , String value ) { <START_BUG> super ( TransactionType . NAMESPACE_METADATA_TRANSACTION , networkType , targetAccount , <END_BUG> scopedMetadataKey , value ) ; Validate . notNull ( targetNamespaceId , "TargetNamespaceId must not be null" ) ; this . targetNamespaceId = targetNamespaceId ;
Assertions . assertEquals ( AccountRestrictionFlags . ALLOW_INCOMING_MOSAIC , transaction . getRestrictionFlags ( ) ) ; Assertions . assertEquals ( 1 , transaction . getRestrictionAdditions ( ) . size ( ) ) ; <START_BUG> Assertions . assertEquals ( TransactionType . MOSAIC_METADATA_TRANSACTION , <END_BUG> transaction . getRestrictionAdditions ( ) . get ( 0 ) ) ; }
AbstractTransactionMapper < MultisigAccountModificationTransactionDTO , MultisigAccountModificationTransaction > { public MultisigAccountModificationTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . MODIFY_MULTISIG_ACCOUNT , <END_BUG> MultisigAccountModificationTransactionDTO . class ) ; }
@ Override public TransactionType getTransactionType ( ) { <START_BUG> return TransactionType . MOSAIC_METADATA_TRANSACTION ; <END_BUG> } @ Override
AbstractTransactionMapper < MosaicMetadataTransactionDTO , MosaicMetadataTransaction > { public MosaicMetadataTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . MOSAIC_METADATA_TRANSACTION , <END_BUG> MosaicMetadataTransactionDTO . class ) ; }
@ Override public TransactionType getTransactionType ( ) { <START_BUG> return TransactionType . NAMESPACE_METADATA_TRANSACTION ; <END_BUG> } @ Override
Assertions . assertEquals ( AccountRestrictionFlags . ALLOW_INCOMING_MOSAIC , transaction . getRestrictionFlags ( ) ) ; Assertions . assertEquals ( 1 , transaction . getRestrictionAdditions ( ) . size ( ) ) ; <START_BUG> Assertions . assertEquals ( TransactionType . MOSAIC_METADATA_TRANSACTION , <END_BUG> transaction . getRestrictionAdditions ( ) . get ( 0 ) ) ; }
byte minRemovalDelta , List < PublicAccount > publicKeyAdditions , List < PublicAccount > publicKeyDeletions ) { <START_BUG> super ( TransactionType . MODIFY_MULTISIG_ACCOUNT , networkType ) ; <END_BUG> Validate . notNull ( publicKeyAdditions , "PublicKeyAdditions must not be null" ) ; Validate . notNull ( publicKeyDeletions , "PublicKeyDeletions must not be null" ) ; this . minApprovalDelta = minApprovalDelta ;
@ Override public TransactionType getTransactionType ( ) { <START_BUG> return TransactionType . REGISTER_NAMESPACE ; <END_BUG> } @ Override
@ Override public TransactionType getTransactionType ( ) { <START_BUG> return TransactionType . MODIFY_MULTISIG_ACCOUNT ; <END_BUG> } @ Override
AbstractTransactionMapper < HashLockTransactionDTO , HashLockTransaction > { public HashLockTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . LOCK , HashLockTransactionDTO . class ) ; <END_BUG> } private Mosaic getMosaic ( HashLockTransactionDTO mosaic ) {
AbstractTransactionMapper < NamespaceRegistrationTransactionDTO , NamespaceRegistrationTransaction > { public NamespaceRegistrationTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . REGISTER_NAMESPACE , <END_BUG> NamespaceRegistrationTransactionDTO . class ) ; }
AbstractTransactionMapper < MosaicMetadataTransactionDTO , MosaicMetadataTransaction > { public MosaicMetadataTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . MOSAIC_METADATA_TRANSACTION , <END_BUG> MosaicMetadataTransactionDTO . class ) ; }
PublicAccount targetAccount , BigInteger scopedMetadataKey , String value ) { <START_BUG> super ( TransactionType . ACCOUNT_METADATA_TRANSACTION , networkType , targetAccount , <END_BUG> scopedMetadataKey , value ) ; }
Mosaic mosaic , BigInteger duration , String hash ) { <START_BUG> super ( TransactionType . LOCK , networkType ) ; <END_BUG> Validate . notNull ( mosaic , "Mosaic must not be null" ) ; Validate . notNull ( duration , "Duration must not be null" ) ; Validate . notNull ( hash , "Hash must not be null" ) ;
expectedReceiptSource ) ; } <START_BUG> if ( transaction . getType ( ) == TransactionType . MOSAIC_METADATA_TRANSACTION ) { <END_BUG> return resolveTransactionFactory ( ( MosaicMetadataTransaction ) transaction , expectedReceiptSource ) ; }
AbstractTransactionMapper < AccountMetadataTransactionDTO , AccountMetadataTransaction > { public AccountMetadataTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . ACCOUNT_METADATA_TRANSACTION , <END_BUG> AccountMetadataTransactionDTO . class ) ; }
String name , LinkedHashMap < String , Object > argNamesWithDefaults , boolean caller , Context localContextScope ) { <START_BUG> super ( content , name , argNamesWithDefaults , caller , localContextScope ) ; <END_BUG> } @ Override
JinjavaInterpreter . popCurrent ( ) ; } <START_BUG> interpreter . addAllErrors ( child . getErrorsCopy ( ) ) ; <END_BUG> for ( Map . Entry < String , String > importMapping : imports . entrySet ( ) ) { Object val = child . getContext ( ) . getGlobalMacro ( importMapping . getKey ( ) ) ;
} MacroFunction macro = new MacroFunction ( tagNode . getChildren ( ) , name , argNamesWithDefaults , <START_BUG> false , interpreter . getContext ( ) ) ; <END_BUG> interpreter . getContext ( ) . addGlobalMacro ( macro ) ; return "" ;
DriverOptions options = new DriverOptions ( context , map , appender , 17556 , "MicrosoftWebDriver" ) ; options . arg ( "--port=" + options . port ) ; Command command = options . startProcess ( ) ; <START_BUG> String urlBase = "http://" + options . host + ":" + options . port ; <END_BUG> Http http = Http . forUrl ( options . driverLogger . getAppender ( ) , urlBase ) ; String sessionId = http . path ( "session" ) . post ( options . getCapabilities ( ) )
DriverOptions options = new DriverOptions ( context , map , appender , 4723 , "appium" ) ; options . arg ( "--port=" + options . port ) ; Command command = options . startProcess ( ) ; <START_BUG> String urlBase = "http://" + options . host + ":" + options . port + "/wd/hub" ; <END_BUG> Http http = Http . forUrl ( options . driverLogger . getAppender ( ) , urlBase ) ; http . config ( "readTimeout" , "120000" ) ; String sessionId = http . path ( "session" )
options . arg ( "--port=" + options . port ) ; options . arg ( "--user-data-dir=" + options . workingDirPath ) ; Command command = options . startProcess ( ) ; <START_BUG> String urlBase = "http://" + options . host + ":" + options . port ; <END_BUG> Http http = Http . forUrl ( options . driverLogger . getAppender ( ) , urlBase ) ; String sessionId = http . path ( "session" ) . post ( options . getCapabilities ( ) )
} options . arg ( "--port=" + options . port ) ; Command command = options . startProcess ( ) ; <START_BUG> String urlBase = "http://" + options . host + ":" + options . port + "/wd/hub" ; <END_BUG> Http http = Http . forUrl ( options . driverLogger . getAppender ( ) , urlBase ) ; http . config ( "readTimeout" , "120000" ) ; String sessionId = http . path ( "session" )
DriverOptions options = new DriverOptions ( context , map , appender , 4444 , "geckodriver" ) ; options . arg ( "--port=" + options . port ) ; Command command = options . startProcess ( ) ; <START_BUG> String urlBase = "http://" + options . host + ":" + options . port ; <END_BUG> Http http = Http . forUrl ( options . driverLogger . getAppender ( ) , urlBase ) ; String sessionId = http . path ( "session" ) . post ( options . getCapabilities ( ) )
DriverOptions options = new DriverOptions ( context , map , appender , 5555 , "safaridriver" ) ; options . arg ( "--port=" + options . port ) ; Command command = options . startProcess ( ) ; <START_BUG> String urlBase = "http://" + options . host + ":" + options . port ; <END_BUG> Http http = Http . forUrl ( options . driverLogger . getAppender ( ) , urlBase ) ; String sessionId = http . path ( "session" ) . post ( options . getCapabilities ( ) )
. accept ( "application/json" ) ; } <START_BUG> protected ExtractableResponse post ( Object body , String url ) { <END_BUG> return request ( Method . POST , body , url ) ; } }
import constant . BookingEndpoint ; import io . restassured . RestAssured ; import io . restassured . http . Method ; <START_BUG> import io . restassured . response . ExtractableResponse ; <END_BUG> import io . restassured . specification . RequestSpecification ; public abstract class AbstractBookerService extends BaseService {
import com . google . common . collect . ImmutableMap ; import io . restassured . http . Method ; <START_BUG> import io . restassured . response . ExtractableResponse ; <END_BUG> import io . restassured . specification . RequestSpecification ; import org . apache . logging . log4j . LogManager ; import org . apache . logging . log4j . Logger ;
} <START_BUG> static class BinEncoder extends Int4s . BinEncoder { <END_BUG> @ Override protected Integer convertInput ( Context context , Type type , Object source , Object sourceContext ) throws ConversionException {
super ( new TxtEncoder ( ) , new TxtDecoder ( ) , new BinEncoder ( ) , new BinDecoder ( ) , "oid" ) ; } <START_BUG> static class BinDecoder extends Int4s . BinDecoder { <END_BUG> @ Override protected Object convertOutput ( Context context , Integer decoded , Class < ? > targetClass , Object targetContext ) throws IOException {
} } <START_BUG> static class TxtDecoder extends Int4s . TxtDecoder { <END_BUG> @ Override protected Object convertOutput ( Context context , Integer decoded , Class < ? > targetClass , Object targetContext ) throws IOException {
} <START_BUG> static class TxtEncoder extends Int4s . TxtEncoder { <END_BUG> @ Override protected Integer convertInput ( Context context , Type type , Object source , Object sourceContext ) throws ConversionException {
public class DataFrame_Sort_Test { @ Test <START_BUG> public void testSort ( ) { <END_BUG> DataFrame dfi = DataFrame . newFrame ( "a" , "b" ) . foldByRow ( 0 , 1 , 2 , 3 ,
@ Test public void whenStudentsScoreRange50to70 ( ) { <START_BUG> List < Student > result = school . collect ( students , s -> s . getScore ( ) >= 50 && s . getScore ( ) < 70 ) ; <END_BUG> List < Student > expected = List . of ( new Student ( "Lomov" , 65 ) , new Student ( "Lomov" , 66 ) ,
@ Test public void whenStudentsScoreRange0to50 ( ) { <START_BUG> List < Student > result = school . collect ( students , s -> s . getScore ( ) > 0 && s . getScore ( ) < 50 ) ; <END_BUG> List < Student > expected = List . of ( new Student ( "Semenov" , 15 ) , new Student ( "Orlov" , 45 ) ,
@ Test public void whenStudentsScoreRange70to100 ( ) { <START_BUG> List < Student > result = school . collect ( students , s -> s . getScore ( ) >= 70 && s . getScore ( ) <= 100 ) ; <END_BUG> List < Student > expected = List . of ( new Student ( "Ivanov" , 75 ) , new Student ( "Petrov" , 100 ) ,
AbstractTransactionMapper < HashLockTransactionDTO , HashLockTransaction > { public HashLockTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . LOCK , HashLockTransactionDTO . class ) ; <END_BUG> } private Mosaic getMosaic ( HashLockTransactionDTO mosaic ) {
AbstractTransactionMapper < NamespaceMetadataTransactionDTO , NamespaceMetadataTransaction > { public NamespaceMetadataTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . NAMESPACE_METADATA_TRANSACTION , <END_BUG> NamespaceMetadataTransactionDTO . class ) ; }
expectedReceiptSource ) ; } <START_BUG> if ( transaction . getType ( ) == TransactionType . LOCK ) { <END_BUG> return resolveTransactionFactory ( ( HashLockTransaction ) transaction , expectedReceiptSource ) ; }
UnresolvedMosaicId targetMosaicId , BigInteger scopedMetadataKey , String value ) { <START_BUG> super ( TransactionType . MOSAIC_METADATA_TRANSACTION , networkType , targetAccount , <END_BUG> scopedMetadataKey , value ) ; Validate . notNull ( targetMosaicId , "TargetMosaicId must not be null" ) ; this . targetMosaicId = targetMosaicId ;
AbstractTransactionMapper < NamespaceRegistrationTransactionDTO , NamespaceRegistrationTransaction > { public NamespaceRegistrationTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . REGISTER_NAMESPACE , <END_BUG> NamespaceRegistrationTransactionDTO . class ) ; }
@ Override public TransactionType getTransactionType ( ) { <START_BUG> return TransactionType . LOCK ; <END_BUG> } @ Override
Validate . notNull ( signedAggregateTransaction , "signedAggregateTransaction is required" ) ; Validate . isTrue ( signedAggregateTransaction . getType ( ) == TransactionType . AGGREGATE_BONDED , "signedAggregateTransaction type must be AGGREGATE_BONDED" ) ; <START_BUG> Validate . isTrue ( signedHashLockTransaction . getType ( ) == TransactionType . LOCK , <END_BUG> "signedHashLockTransaction type must be LOCK" ) ; return announce ( listener , signedHashLockTransaction ) . flatMap ( t -> announceAggregateBonded ( listener , signedAggregateTransaction ) ) ;
final NamespaceRegistrationType namespaceRegistrationType , final Optional < BigInteger > duration , final Optional < NamespaceId > parentId ) { <START_BUG> super ( TransactionType . REGISTER_NAMESPACE , networkType ) ; <END_BUG> Validate . notNull ( namespaceName , "NamespaceName must not be null" ) ; Validate . notNull ( namespaceRegistrationType , "NamespaceType must not be null" ) ; Validate . notNull ( namespaceId , "NamespaceId must not be null" ) ;
@ Override public TransactionType getTransactionType ( ) { <START_BUG> return TransactionType . ACCOUNT_METADATA_TRANSACTION ; <END_BUG> } @ Override
AbstractTransactionMapper < AccountMetadataTransactionDTO , AccountMetadataTransaction > { public AccountMetadataTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . ACCOUNT_METADATA_TRANSACTION , <END_BUG> AccountMetadataTransactionDTO . class ) ; }
NamespaceId targetNamespaceId , BigInteger scopedMetadataKey , String value ) { <START_BUG> super ( TransactionType . NAMESPACE_METADATA_TRANSACTION , networkType , targetAccount , <END_BUG> scopedMetadataKey , value ) ; Validate . notNull ( targetNamespaceId , "TargetNamespaceId must not be null" ) ; this . targetNamespaceId = targetNamespaceId ;
Assertions . assertEquals ( AccountRestrictionFlags . ALLOW_INCOMING_MOSAIC , transaction . getRestrictionFlags ( ) ) ; Assertions . assertEquals ( 1 , transaction . getRestrictionAdditions ( ) . size ( ) ) ; <START_BUG> Assertions . assertEquals ( TransactionType . MOSAIC_METADATA_TRANSACTION , <END_BUG> transaction . getRestrictionAdditions ( ) . get ( 0 ) ) ; }
AbstractTransactionMapper < MultisigAccountModificationTransactionDTO , MultisigAccountModificationTransaction > { public MultisigAccountModificationTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . MODIFY_MULTISIG_ACCOUNT , <END_BUG> MultisigAccountModificationTransactionDTO . class ) ; }
@ Override public TransactionType getTransactionType ( ) { <START_BUG> return TransactionType . MOSAIC_METADATA_TRANSACTION ; <END_BUG> } @ Override
AbstractTransactionMapper < MosaicMetadataTransactionDTO , MosaicMetadataTransaction > { public MosaicMetadataTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . MOSAIC_METADATA_TRANSACTION , <END_BUG> MosaicMetadataTransactionDTO . class ) ; }
@ Override public TransactionType getTransactionType ( ) { <START_BUG> return TransactionType . NAMESPACE_METADATA_TRANSACTION ; <END_BUG> } @ Override
Assertions . assertEquals ( AccountRestrictionFlags . ALLOW_INCOMING_MOSAIC , transaction . getRestrictionFlags ( ) ) ; Assertions . assertEquals ( 1 , transaction . getRestrictionAdditions ( ) . size ( ) ) ; <START_BUG> Assertions . assertEquals ( TransactionType . MOSAIC_METADATA_TRANSACTION , <END_BUG> transaction . getRestrictionAdditions ( ) . get ( 0 ) ) ; }
AbstractTransactionMapper < MultisigAccountModificationTransactionDTO , MultisigAccountModificationTransaction > { public MultisigAccountModificationTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . MODIFY_MULTISIG_ACCOUNT , <END_BUG> MultisigAccountModificationTransactionDTO . class ) ; }
byte minRemovalDelta , List < PublicAccount > publicKeyAdditions , List < PublicAccount > publicKeyDeletions ) { <START_BUG> super ( TransactionType . MODIFY_MULTISIG_ACCOUNT , networkType ) ; <END_BUG> Validate . notNull ( publicKeyAdditions , "PublicKeyAdditions must not be null" ) ; Validate . notNull ( publicKeyDeletions , "PublicKeyDeletions must not be null" ) ; this . minApprovalDelta = minApprovalDelta ;
@ Override public TransactionType getTransactionType ( ) { <START_BUG> return TransactionType . REGISTER_NAMESPACE ; <END_BUG> } @ Override
@ Override public TransactionType getTransactionType ( ) { <START_BUG> return TransactionType . MODIFY_MULTISIG_ACCOUNT ; <END_BUG> } @ Override
AbstractTransactionMapper < HashLockTransactionDTO , HashLockTransaction > { public HashLockTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . LOCK , HashLockTransactionDTO . class ) ; <END_BUG> } private Mosaic getMosaic ( HashLockTransactionDTO mosaic ) {
AbstractTransactionMapper < NamespaceRegistrationTransactionDTO , NamespaceRegistrationTransaction > { public NamespaceRegistrationTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . REGISTER_NAMESPACE , <END_BUG> NamespaceRegistrationTransactionDTO . class ) ; }
AbstractTransactionMapper < MosaicMetadataTransactionDTO , MosaicMetadataTransaction > { public MosaicMetadataTransactionMapper ( JsonHelper jsonHelper ) { <START_BUG> super ( jsonHelper , TransactionType . MOSAIC_METADATA_TRANSACTION , <END_BUG> MosaicMetadataTransactionDTO . class ) ; }
PublicAccount targetAccount , BigInteger scopedMetadataKey , String value ) { <START_BUG> super ( TransactionType . ACCOUNT_METADATA_TRANSACTION , networkType , targetAccount , <END_BUG> scopedMetadataKey , value ) ; }
Mosaic mosaic , BigInteger duration , String hash ) { <START_BUG> super ( TransactionType . LOCK , networkType ) ; <END_BUG> Validate . notNull ( mosaic , "Mosaic must not be null" ) ; Validate . notNull ( duration , "Duration must not be null" ) ; Validate . notNull ( hash , "Hash must not be null" ) ;
expectedReceiptSource ) ; } <START_BUG> if ( transaction . getType ( ) == TransactionType . MOSAIC_METADATA_TRANSACTION ) { <END_BUG> return resolveTransactionFactory ( ( MosaicMetadataTransaction ) transaction , expectedReceiptSource ) ; }
* @ param iBMag electric current magnitude @ port B , normally provided in Ampere * @ param iBAng electric current angle @ Port B in degree * / <START_BUG> public Transformer2wResult ( <END_BUG> ZonedDateTime timestamp , UUID inputModel , Quantity < ElectricCurrent > iAMag ,
* @ param iBMag electric current magnitude @ port B , normally provided in Ampere * @ param iBAng electric current angle @ Port B in degree * / <START_BUG> public Transformer2wResult ( <END_BUG> UUID uuid , ZonedDateTime timestamp , UUID inputModel ,
} private SystemParticipantResult buildModel ( SimpleEntityData simpleEntityData ) { <START_BUG> Map < String , String > fieldsToAttributes = simpleEntityData . getFieldsToAttributes ( ) ; <END_BUG> Class < ? extends UniqueEntity > clazz = simpleEntityData . getEntityClass ( ) ; ZonedDateTime zdtTimestamp = TimeTools . toZonedDateTime ( fieldsToAttributes . get ( timestamp ) ) ;
this . entityClass = entityClass ; } <START_BUG> public Map < String , String > getFieldsToAttributes ( ) { <END_BUG> return fieldsToAttributes ; }
* @ version 0.1 * @ since 28.01 .20 * / <START_BUG> abstract class EntityData { <END_BUG> private final Map < String , String > fieldsToAttributes ; private final Class < ? extends UniqueEntity > entityClass ;
private boolean isBaseMap = false ; private boolean isInternal = false ; <START_BUG> private int dataproviderId ; <END_BUG> private String name ; private String url ;
changedFileMetadata . add ( fmdo ) ; changedFileMetadata . add ( fmdn ) ; } <START_BUG> if ( ! compareVariableMetadata ( fmdo , fmdn ) || ! compareVarGroup ( fmdo , fmdn ) ) { <END_BUG> changedVariableMetadata . add ( fmdo ) ; changedVariableMetadata . add ( fmdn ) ; }
